---
layout: post
title: C++ 设计模式之面向对象程序设计原则
date: 2015-10-12
tags:
	- 设计模式
---

变化是复用的天敌！面向对象设计（基于抽象）的最大的优势在于：**抵御变化！**

<!-- more -->
### 重新认识面向对象

-	理解隔离变化
	-	从宏观层面来看，面向对象的构建方式更能适应软件的变化，能将变化带来的影响减为最小
-	各司其职（基于多态，接口相同，实现不同）
	-	从**微观层面**来看，面向对象的方式更强调各类的“责任”
	-	由于需求变化导致的新增类型不应该影响原来类型的实现 ---- 各负其责
-	对象是什么？
	-	从语言实现层面来看，对象封装了代码和数据
	-	从规格层面将，对象是一系列可被使用的公共接口
	-	从概念层面讲，对象是某种拥有责任的抽象

### 面向对象的设计原则

1.	依赖倒置原则(Dependency Inversion Principle DIP)
	-	高层模块（`MainFrom`）（稳定）不应该依赖于底层模块(`Line/Rect`)[^1]（变化），二者都应该依赖于抽象（稳定）[^2]
	-	抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。
![](http://img.hb.aicdn.com/150407d5caffd80467ee1cf81457069c0928012e44a2-d4UdBX_fw658)
2.	开放封闭原则(Open-close principle OCP)
	-	对扩展(增加)开放，对改变封闭
	-	类模块（抽象类）应该是可扩展[^3]的，但是不可修改，使用扩展的方式应对需求的变更，而不是修改。

3.	单一职责原则(Single Responsibility Principle, SRP)
	-	一个类应该仅有一个引起变化的原因
	-	变化的方向隐含着**类的责任**

`SRP` 是用来控制类的粒度的大小，一个类只负责一个功能领域中的相应职责。在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。
4.	`Liskov` 替换原则 (Liskov substitution principle LSP) -- `is a`
	-	子类必须能够替换它们的基类
	-	继承表达类型抽象

5.	接口隔离原则(Interface segeregation principle ISP)
	-	不应该强迫客户程序依赖它们不用的方法
	-	接口小儿完备

6.	优先使用对象组合，而不是类继承
	-	类继承通常为“白箱复用”，对象复用通常为“黑箱复用”，继承应该为从属关系
	-	继承在某种程度上破坏了封装性，子类父类耦合度高
	-	而对象组合只要求被组合的对象具有良好的定义和接口，耦合度低

7.	封装变换点
	-	使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合

8.	针对接口编程，而不是针对实现编程
	-	不将变量类型申明为某个特定的具体类（应该声明为抽象类），而是声明为某个接口（Draw）
	-	客户程序无需获知对象的具体类型，只需要知道对象具有的接口
	-	减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案
9.	面向接口的设计
	-	接口标准---分工协作（生产线，国际标准件）


### 将设计原则提升为设计经验
1.	设计习语-Design Idioms
	Design Idioms 描述与特定编程语言相关的低层模式，技巧，惯用法。
2.	设计模式 Design Patterns
	Design Patterns 主要描述的是“类与相互通信的对象之间的组织关系，包括它们的角色、职责、协作方式等方面。
3.	架构模式 Architectural Patterns
	rchitectural Patterns 描述系统中与基本结构组织关系密切的高层模式，包括子系统划分，职责，以及如何组织它们之间关系的规则。

[^1]:`MainForm`依赖于于具体的类（变化）
[^2]: MainForm依赖于`shape`，`line`和`rect`依赖于`shape`
[^3]: `circle`类的添加
